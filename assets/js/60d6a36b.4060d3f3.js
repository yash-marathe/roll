"use strict";(globalThis.webpackChunkdocs_roll=globalThis.webpackChunkdocs_roll||[]).push([[9495],{28453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>o});var i=t(96540);const r={},s=i.createContext(r);function a(e){const n=i.useContext(s);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),i.createElement(s.Provider,{value:n},e.children)}},93879:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>a,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"Development/Developer Guide/customer_env","title":"Customer Env","description":"Reinforcement Learning Environment","source":"@site/docs/Development/Developer Guide/customer_env.md","sourceDirName":"Development/Developer Guide","slug":"/Development/Developer Guide/customer_env","permalink":"/ROLL/docs/Development/Developer Guide/customer_env","draft":false,"unlisted":false,"editUrl":"https://github.com/alibaba/ROLL/tree/main/docs_roll/docs/Development/Developer Guide/customer_env.md","tags":[],"version":"current","lastUpdatedAt":1764581625000,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"How to Add Support for a New Model","permalink":"/ROLL/docs/Development/Developer Guide/support_new_models"},"next":{"title":"Prompt Generation Guide","permalink":"/ROLL/docs/Development/Developer Guide/prompt_intro"}}');var r=t(74848),s=t(28453);const a={},o="Customer Env",l={},c=[{value:"Reinforcement Learning Environment",id:"reinforcement-learning-environment",level:2},{value:"Core Functional Requirements",id:"core-functional-requirements",level:2},{value:"Code Examples",id:"code-examples",level:2},{value:"Sokoban Environment: Discrete Action Classic Puzzle Task",id:"sokoban-environment-discrete-action-classic-puzzle-task",level:3},{value:"WebShop Environment: Complex Natural Language-Driven Interaction Task",id:"webshop-environment-complex-natural-language-driven-interaction-task",level:3},{value:"Creating a Custom Env",id:"creating-a-custom-env",level:2},{value:"Step Overview",id:"step-overview",level:3},{value:"Design Suggestions",id:"design-suggestions",level:3}];function d(e){const n={code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"customer-env",children:"Customer Env"})}),"\n",(0,r.jsx)(n.h2,{id:"reinforcement-learning-environment",children:"Reinforcement Learning Environment"}),"\n",(0,r.jsxs)(n.p,{children:["In Reinforcement Learning (RL), the ",(0,r.jsx)(n.strong,{children:"Environment"})," is the world where the ",(0,r.jsx)(n.strong,{children:"Agent"})," interacts with. It defines the ",(0,r.jsx)(n.strong,{children:"States"})," that the agent can perceive, the ",(0,r.jsx)(n.strong,{children:"Actions"})," it can execute, and the ",(0,r.jsx)(n.strong,{children:"Reward"})," the agent receives after each interaction. The environment is responsible for simulating the dynamics of the real world, updating its state based on the agent's actions, and providing feedback."]}),"\n",(0,r.jsx)(n.p,{children:"To help you quickly get started and understand the adaptability and performance of our ROLL framework's Agentic Pipeline across various task scenarios, we specifically provide two main types of example environments:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Traditional RL Environments based on ",(0,r.jsx)(n.strong,{children:"Discrete Actions"})," (inheriting from ",(0,r.jsx)(n.em,{children:"BaseDiscreteActionEnv"}),"): Such as Sokoban (Push Box Puzzle) and FrozenLake (Sliding Maze). These represent classic RL challenges like discrete action control and uncertain state transitions."]}),"\n",(0,r.jsxs)(n.li,{children:["Complex Environments based on ",(0,r.jsx)(n.strong,{children:"Natural Language Interaction"})," (inheriting from *BaseLanguageBasedEnv): Such as WebShop (Online Shopping Simulation) and Countdown (Number Game). These represent advanced LLM Agent challenges like complex natural language understanding and generation, multi-step planning, and reasoning."]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"core-functional-requirements",children:"Core Functional Requirements"}),"\n",(0,r.jsx)(n.p,{children:"A standard environment (Env) typically implements the following functionalities:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Observation Space","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Definition: Specifies the format, range, and type of information the agent can obtain from the environment."}),"\n",(0,r.jsx)(n.li,{children:"Examples: Box(low=0, high=255, shape=(84, 84, 3))\xa0for image inputs, or Text(max_length=8192)\xa0for long text inputs."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["Action Space","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Definition: Specifies the types and ranges of actions the agent can execute."}),"\n",(0,r.jsx)(n.li,{children:"Examples: Discrete(n=4)\xa0for discrete actions (e.g., up, down, left, right), or\xa0Text(max_length=256)\xa0for text generation actions (e.g., WebShop search operations)."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["reset()\xa0","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Triggered: At the start of each training episode."}),"\n",(0,r.jsx)(n.li,{children:"Function: Resets the environment to an initial state and returns the initial observation."}),"\n",(0,r.jsx)(n.li,{children:"Standard Output: initial_observation, info\xa0(an optional auxiliary dictionary)."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["step(action)","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Triggered: After the agent executes an action."}),"\n",(0,r.jsx)(n.li,{children:"Function: Updates the environment state, calculates rewards, and determines if the episode has ended."}),"\n",(0,r.jsxs)(n.li,{children:["Standard Output:","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"next_observation: The new observation after the action."}),"\n",(0,r.jsx)(n.li,{children:"reward: The reward received by the agent (float)."}),"\n",(0,r.jsx)(n.li,{children:"terminated: Boolean indicating if the episode ended naturally (e.g., game failure, goal achieved)."}),"\n",(0,r.jsx)(n.li,{children:"truncated: Boolean indicating if the episode ended due to time limits or other non-natural conditions."}),"\n",(0,r.jsx)(n.li,{children:"info:  A dictionary containing diagnostic information (e.g., debug data, not for agent input)."}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["render()\xa0(Optional)","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Function: Visualizes the environment state (e.g., graphical interface)."}),"\n",(0,r.jsx)(n.li,{children:"Headless Mode: Not required in headless training scenarios."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["close()\xa0\u65b9\u6cd5 (Optional)","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Function: Cleans up environment resources (e.g., closes rendering windows or releases file handles)."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"code-examples",children:"Code Examples"}),"\n",(0,r.jsx)(n.h3,{id:"sokoban-environment-discrete-action-classic-puzzle-task",children:"Sokoban Environment: Discrete Action Classic Puzzle Task"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"Environment Configuration"}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'class SokobanEnvConfig:\n    # Room dimensions (rows, columns)\n    dim_room: Tuple[int, int] = (6, 6) \n    # Maximum steps per episode\n    max_steps: int = 100 \n    # Number of boxes in the room\n    num_boxes: int = 3 \n    # Search depth for generating solvable rooms\n    search_depth: int = 300 \n    # Mapping from grid element integer IDs to character representations (for text rendering)\n    grid_lookup: Optional[Dict[int, str]] = field(\n        default_factory=lambda: {0: "#", 1: "_", 2: "O", 3: "\u221a", 4: "X", 5: "P", 6: "S"}\n    )\n    # Mapping from grid elements to readable names\n    grid_vocab: Optional[Dict[str, str]] = field(\n        default_factory=lambda: {\n            "#": "wall",\n            "_": "empty",\n            "O": "target",\n            "\u221a": "box on target",\n            "X": "box",\n            "P": "player",\n            "S": "player on target",\n        }\n    )\n    # Mapping from action IDs to action names (1: Up, 2: Down, 3: Left, 4: Right)\n    action_lookup: Optional[Dict[int, str]] = field(\n        default_factory=lambda: {1: "Up", 2: "Down", 3: "Left", 4: "Right"}\n    )\n    # Compatibility fields for setting dim_room via dim_x/dim_y\n    dim_x: Optional[int] = None\n    dim_y: Optional[int] = None\n    render_mode: str = "text"\n'})}),"\n",(0,r.jsxs)(n.ol,{start:"2",children:["\n",(0,r.jsxs)(n.li,{children:["Environment Implementation ",(0,r.jsx)(n.strong,{children:"SokobanEnv"}),"\nThis is a standard RL environment implementation, inheriting from BaseDiscreteActionEnv (generic interface for discrete-action environments) and GymSokobanEnv (core logic for the Sokoban game)."]}),"\n"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Action Space Definition: 4 discrete actions starting from 1 (up, down, left, right):"}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"self.ACTION_SPACE = gym.spaces.discrete.Discrete(4, start=1)\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"reset()\uff1aGenerates a new Sokoban room layout and resets internal state:"}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"def reset(self, seed=None):\n    try:\n        # Ensures reproducibility of room generation\n        with all_seed(seed):\n            # Call generate_room to create a new room\n            self.room_fixed, self.room_state, self.box_mapping, action_sequence = generate_room(\n                dim=self.dim_room,\n                num_steps=self.num_gen_steps,  # The number of steps required to generate a room\n                num_boxes=self.num_boxes,\n                search_depth=self.search_depth,\n            )\n        # Reset counters and state\n        self.num_env_steps, self.reward_last, self.boxes_on_target = 0, 0, 0\n        self.player_position = np.argwhere(self.room_state == 5)[0]  # Find player's initial position\n        \n        # Return initial observation\n        return self.render()\n    except (RuntimeError, RuntimeWarning) as e:\n        # Retry with a new seed if room generation fails\n        next_seed = abs(hash(str(seed))) % (2**32) if seed is not None else None\n        return self.reset(next_seed)\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"step(action): Executes an action and updates the state:"}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'def step(self, action: int):\n    # Record player\'s old position to determine if action was effective\n    previous_pos = self.player_position\n    \n    # Call parent class GymSokobanEnv\'s step method to execute the action\n    _, reward, done, _ = GymSokobanEnv.step(self, action)\n    \n    # Get the new observation after executing the action\n    next_obs = self.render()\n    \n    # Determine if the action actually changed the player\'s position\n    action_effective = not np.array_equal(previous_pos, self.player_position)\n    \n    # Construct and return auxiliary information dictionary\n    info = {\n        "action_is_effective": action_effective,  # Whether the action actually moved the player or a box\n        "action_is_valid": True, # Whether the input action ID is valid (even if hitting a wall)\n        "success": self.boxes_on_target == self.num_boxes, # Whether all boxes are on target (game won)\n    }\n\n    # Return standard reinforcement learning environment step results (next_observation, reward, terminated, info)\n    return next_obs, reward, done, info\n'})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"render()\uff1aRenders the current environment state as text or an image."}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'def render(self, mode=None):\n    # Use specified mode or default mode\n    render_mode = mode if mode is not None else self.render_mode \n    \n    if render_mode == "text":\n        # Text rendering: Convert internal numeric representation of room state to ASCII character grid\n        room = np.where((self.room_state == 5) & (self.room_fixed == 2), 6, self.room_state)\n        return "\\n".join("".join(self.GRID_LOOKUP.get(cell, "?") for cell in row) for row in room.tolist())\n    elif render_mode == "rgb_array":\n        # Image rendering: Delegate to parent class GymSokobanEnv\'s get_image method\n        return self.get_image(mode="rgb_array", scale=1)\n    else:\n        raise ValueError(f"Invalid mode: {render_mode}")\n'})}),"\n",(0,r.jsxs)(n.ol,{start:"3",children:["\n",(0,r.jsx)(n.li,{children:"Module Test"}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'import matplotlib.pyplot as plt\n# Create a Sokoban environment configuration\nconfig = SokobanEnvConfig(dim_room=(6, 6), num_boxes=1, max_steps=100, search_depth=10)\n# Create a Sokoban environment instance using this configuration\nenv = SokobanEnv(config)\n# Loop 10 times, resetting the environment with a different seed each time, and print the initial state to observe different room layouts.\nfor i in range(10):\n    # Reset environment with a seed\n    print(env.reset(seed=1010 + i))\n    print()\n# Enter an interactive loop, allowing the user to control the agent via keyboard input.\nwhile True:\n    keyboard = input("Enter action: ")\n    if keyboard == "q":\n        break\n    # Convert input to integer action ID\n    action = int(keyboard)\n    assert action in env.ACTION_LOOKUP, f"Invalid action: {action}"\n    # Execute the action, get new observation, reward, done state, and info\n    obs, reward, done, info = env.step(action)\n    print(obs, reward, done, info)\n# If the environment supports RGB array rendering, get the final game screen image.\nnp_img = env.get_image("rgb_array")\n# Save the image\nplt.imsave("sokoban1.png", np_img)\n'})}),"\n",(0,r.jsx)(n.h3,{id:"webshop-environment-complex-natural-language-driven-interaction-task",children:"WebShop Environment: Complex Natural Language-Driven Interaction Task"}),"\n",(0,r.jsx)(n.p,{children:"WebShop is a simulated online shopping environment that requires agents to complete tasks like searching, selecting products, viewing details, and placing orders based on natural language instructions. Each trajectory includes up to 50 steps, demanding strong contextual understanding and task execution efficiency."}),"\n",(0,r.jsx)(n.p,{children:"The following section focuses on the differences from the Sokoban environment:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"WebShop parses available actions in the environment and converts them into a list of text strings that the agent can generate."}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'def get_available_actions(self):\n    # Get raw available action information from the underlying WebShop simulator\n    # Unlike Sokoban\'s fixed action set, WebShop\'s action space is dynamic.\n    orig_available_actions = WebAgentTextEnv.get_available_actions(self) \n    available_actions = []\n    # Define text format for search actions\n    if orig_available_actions["has_search_bar"]:\n        available_actions.append("search[<content>]") \n    # Define text format for click actions\n    for clickable in orig_available_actions["clickables"]:\n        if clickable != "search":\n            available_actions.append(f"click[{clickable}]") \n    # Return a list of strings, instructing the Agent which string to generate \n    return available_actions\n'})}),"\n",(0,r.jsxs)(n.ol,{start:"2",children:["\n",(0,r.jsx)(n.li,{children:"WebShop's reset can specify a session ID and initial instruction text."}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'def reset(\n    self, seed=None, session: Optional[Union[str, int]] = None, instruction_text: Optional[str] = None\n) -> any:\n  \n    # Session ID management: If not provided, generate a random one\n    if session is None:\n        with all_seed(seed):\n            session = "".join(random.choices(string.ascii_lowercase, k=10))\n    \n    # Call parent class WebAgentTextEnv\'s reset, which returns text observation\n    obs, _ = WebAgentTextEnv.reset(self, session=session, instruction_text=instruction_text)\n    \n    # Prepare render cache: Add initial instruction to cache for render method\n  self.prepare_render_cache(WebAgentTextEnv.get_instruction_text(self))\n    return obs\n'})}),"\n",(0,r.jsxs)(n.ol,{start:"3",children:["\n",(0,r.jsx)(n.li,{children:"WebShop's action is a natural language text string."}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'def step(self, action):\n    # Call parent class WebAgentTextEnv\'s step, which parses and executes text actions\n    state, reward, done, info = WebAgentTextEnv.step(self, action)\n    \n    # Prepare render cache: Update cached observation\n    self.prepare_render_cache(self.observation)\n    \n    # Construct auxiliary information dictionary\n    info = {\n        "action_is_effective": tuple(self.get_available_actions()) \n        == ("click[back to search]", "click[< prev]", "click[next >]"), \n        "action_is_valid": True,\n        "success": done, \n    }\n    return self.observation, reward, done, info\n'})}),"\n",(0,r.jsx)(n.h2,{id:"creating-a-custom-env",children:"Creating a Custom Env"}),"\n",(0,r.jsx)(n.h3,{id:"step-overview",children:"Step Overview"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"Choose a Base Class: Select to inherit from BaseDiscreteActionEnv or BaseLanguageBasedEnv based on your task type (discrete actions or language interaction)."}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"Define init: Initialize environment parameters, define observation_space and action_space."}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"Implement reset(): Define the initial state of the environment."}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"Implement step(action): Define how the environment updates its state, calculates rewards, and determines episode termination based on an action."}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"Implement render(): Define the environment's rendering logic."}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"Implement close(): Define resource cleanup logic."}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"design-suggestions",children:"Design Suggestions"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["State Representation","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Discrete Action Environments: Structured grid states, position information, etc."}),"\n",(0,r.jsx)(n.li,{children:"Language Environments: Text observations should contain all relevant context (e.g., full web page content, instructions) and consider context window limits. Too much redundant information can lead to LLM inefficiency or inability to process."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["Action Space Design","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Discrete Action Environments: Actions are predefined integer or enumerated values."}),"\n",(0,r.jsx)(n.li,{children:"Language Environments: Actions are natural language text. This requires the agent to have natural language generation capabilities, and the environment needs to be able to parse and validate these text actions."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["Reward Function Design","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Clear Goals: Rewards should clearly guide the agent towards the desired behavior."}),"\n",(0,r.jsxs)(n.li,{children:["Sparse vs. Dense Rewards","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Discrete Action Environments: Rewards are usually given upon completing subgoals or final goals."}),"\n",(0,r.jsxs)(n.li,{children:["Language Environments:","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"WebShop may have sparse rewards, but intermediate rewards can also be designed."}),"\n",(0,r.jsx)(n.li,{children:"Countdown uses hierarchical rewards (0, format score, full score) to guide learning."}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.li,{children:"Avoid Reward Hacking: Ensure the agent cannot achieve high rewards through unintended means."}),"\n",(0,r.jsx)(n.li,{children:"Format Penalty: In language environments, imposing penalties for text actions that do not conform to the expected format is crucial; it effectively guides the LLM to generate structured and parsable output."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["Episode Termination Conditions","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Clearly define conditions for success, failure, or timeout to end a training episode. Use terminated and truncated to denote natural and non-natural termination, respectively."}),"\n",(0,r.jsx)(n.li,{children:"WebShop also has a maximum step limit."}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.li,{children:"Uncertainty/Randomness: If the environment includes uncertainty (like FrozenLake), ensure its behavior follows a predictable probability distribution and that randomness can be controlled via a seed in reset."}),"\n",(0,r.jsx)(n.li,{children:"Reproducibility: Use the seed parameter to initialize random number generators to ensure that the environment's behavior is reproducible across runs."}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}}}]);