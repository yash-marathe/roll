"use strict";(globalThis.webpackChunkdocs_roll=globalThis.webpackChunkdocs_roll||[]).push([[3680],{27048:(e,t,i)=>{i.r(t),i.d(t,{assets:()=>c,contentTitle:()=>o,default:()=>p,frontMatter:()=>l,metadata:()=>n,toc:()=>s});const n=JSON.parse('{"id":"Development/Architecture/AgenticPipeline","title":"AgenticPipeline","description":"Agentic Pipeline Architecture Diagram","source":"@site/docs/Development/Architecture/AgenticPipeline.md","sourceDirName":"Development/Architecture","slug":"/Development/Architecture/AgenticPipeline","permalink":"/ROLL/docs/Development/Architecture/AgenticPipeline","draft":false,"unlisted":false,"editUrl":"https://github.com/alibaba/ROLL/tree/main/docs_roll/docs/Development/Architecture/AgenticPipeline.md","tags":[],"version":"current","lastUpdatedAt":1764225914000,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"ROLL x Ascend","permalink":"/ROLL/docs/User Guides/Hardware Support/ascend_usage"},"next":{"title":"RLVR Pipeline","permalink":"/ROLL/docs/Development/Architecture/RLVRPipeline"}}');var r=i(74848),a=i(28453);const l={},o="AgenticPipeline",c={},s=[{value:"Agentic Pipeline Architecture Diagram",id:"agentic-pipeline-architecture-diagram",level:2},{value:"AgenticPipeline",id:"agenticpipeline-1",level:2},{value:"Main Attributes",id:"main-attributes",level:3},{value:"Core Configuration",id:"core-configuration",level:4},{value:"Actor-Critic Architecture Clusters",id:"actor-critic-architecture-clusters",level:4},{value:"Environment Interaction Scheduler",id:"environment-interaction-scheduler",level:4},{value:"Controllers and Auxiliary Tools",id:"controllers-and-auxiliary-tools",level:4},{value:"Core Process",id:"core-process",level:3},{value:"model_update",id:"model_update",level:4},{value:"train_rollout",id:"train_rollout",level:4},{value:"val_rollout",id:"val_rollout",level:4},{value:"cal_ref_log_probs",id:"cal_ref_log_probs",level:4},{value:"cal_old_log_probs_values",id:"cal_old_log_probs_values",level:4},{value:"adv",id:"adv",level:4},{value:"critic.train_step (optional)",id:"critictrain_step-optional",level:4},{value:"actor_train.train_step",id:"actor_traintrain_step",level:4},{value:"compute_data_metrics",id:"compute_data_metrics",level:4},{value:"do_checkpoint",id:"do_checkpoint",level:4},{value:"tracker.log",id:"trackerlog",level:4}];function d(e){const t={code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",img:"img",li:"li",p:"p",pre:"pre",ul:"ul",...(0,a.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.header,{children:(0,r.jsx)(t.h1,{id:"agenticpipeline",children:"AgenticPipeline"})}),"\n",(0,r.jsx)(t.h2,{id:"agentic-pipeline-architecture-diagram",children:"Agentic Pipeline Architecture Diagram"}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.img,{src:"https://img.alicdn.com/imgextra/i1/O1CN01WtFEA01siugMLjRsj_!!6000000005801-2-tps-4602-4230.png",alt:"Agentic Pipeline Architecture Diagram"})}),"\n",(0,r.jsx)(t.h2,{id:"agenticpipeline-1",children:"AgenticPipeline"}),"\n",(0,r.jsx)(t.p,{children:"AgenticPipeline is a core component in the ROLL framework, used for reinforcement learning training of agents. AgenticPipeline inherits from BasePipeline and implements the PPO (Proximal Policy Optimization) algorithm based on the Actor-Critic architecture, providing a complete distributed training pipeline for large language model agent training."}),"\n",(0,r.jsx)(t.h3,{id:"main-attributes",children:"Main Attributes"}),"\n",(0,r.jsx)(t.h4,{id:"core-configuration",children:"Core Configuration"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:"pipeline_config: The core configuration object of the AgenticPipeline class, of type AgenticConfig, containing all configuration parameters for the entire reinforcement learning training pipeline."}),"\n"]}),"\n",(0,r.jsx)(t.h4,{id:"actor-critic-architecture-clusters",children:"Actor-Critic Architecture Clusters"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:"actor_train: The policy network training cluster in AgenticPipeline, responsible for executing the core training logic of the PPO algorithm."}),"\n",(0,r.jsx)(t.li,{children:"actor_infer: The policy network inference cluster in AgenticPipeline, responsible for interacting with the environment to generate training data."}),"\n",(0,r.jsx)(t.li,{children:"reference: The reference model cluster in AgenticPipeline, serving as a baseline model in the policy optimization process for calculating KL divergence."}),"\n",(0,r.jsx)(t.li,{children:"critic (optional): Estimates the state value function (only used in GAE mode)"}),"\n"]}),"\n",(0,r.jsx)(t.h4,{id:"environment-interaction-scheduler",children:"Environment Interaction Scheduler"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:"train_rollout_scheduler: Collects experience data during training, where infer_cluster=actor_infer"}),"\n",(0,r.jsx)(t.li,{children:"val_rollout_scheduler: Collects experience data during validation to evaluate model performance, where infer_cluster=actor_infer"}),"\n"]}),"\n",(0,r.jsx)(t.h4,{id:"controllers-and-auxiliary-tools",children:"Controllers and Auxiliary Tools"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:"kl_ctrl: Adaptively adjusts the KL penalty coefficient to prevent the policy update from deviating too far from the reference policy"}),"\n",(0,r.jsx)(t.li,{children:"tokenizer: Handles text encoding and decoding"}),"\n",(0,r.jsx)(t.li,{children:"running: Calculates and maintains runtime statistics"}),"\n"]}),"\n",(0,r.jsx)(t.h3,{id:"core-process",children:"Core Process"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-python",children:"def run():\n    Initialize TPS timer\n    for global_step in range(max_steps):\n        # 1. Model state management\n        Update model parameters (actor_train -> actor_infer)\n        # 2. Evaluation phase (executed every eval_steps)\n        if global_step % eval_steps == 0:\n            batch = Validation environment rollout(val_batch_size)\n            Calculate evaluation metrics (score mean/max/min)\n            Save render results (optional) \n        # 3. Training data collection\n        batch = Training environment rollout(rollout_batch_size)\n        # 4. Calculate key probabilities and values\n        ref_log_probs = Reference model.calculate log probabilities(batch)\n        old_log_probs = Actor_train model.calculate log probabilities(batch)\n        if using GAE estimator:\n            values = Critic model.calculate value function(batch)\n        # 5. Reward processing and advantage calculation\n        Normalize reward scores by group\n        Apply KL penalty\n        Calculate advantage function (GAE or other methods)\n        # 6. Model training\n        if using GAE estimator:\n            Critic model.training step(batch)\n        if global_step > critic_warmup:\n            Actor model.training step(batch)\n        # 7. Record and save\n        Record training metrics\n        Save checkpoints\n        Print sample logs (every logging_steps)\n"})}),"\n",(0,r.jsx)(t.h4,{id:"model_update",children:"model_update"}),"\n",(0,r.jsx)(t.p,{children:"Synchronize training model parameters to the inference model to ensure that the inference model used for generating rollout data uses the latest training parameters. In the PPO algorithm, the training model actor_train is responsible for parameter updates and gradient calculations, while the inference model actor_infer is responsible for generating rollout data. To ensure training consistency, the inference model needs to periodically synchronize the latest training data, so that the generated rollout data can reflect the true performance of the current policy."}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-python",children:"# Initialize phase to set synchronization pairs\nself.set_model_update_pair(\n            src_cluster=self.actor_train,\n            tgt_cluster=self.actor_infer,\n      frequency=self.pipeline_config.actor_train.model_update_frequency,)\n\n# Execute synchronization in training loop\nmodel_update_metrics: Dict = self.model_update(global_step)\nmetrics.update(model_update_metrics)\n"})}),"\n",(0,r.jsx)(t.h4,{id:"train_rollout",children:"train_rollout"}),"\n",(0,r.jsx)(t.p,{children:"Generate rollout data for training, i.e., let the agent interact with the environment to produce experience data (state, action, reward sequences)."}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-python",children:"self.train_rollout_scheduler.get_batch(batch, self.pipeline_config.rollout_batch_size)\n"})}),"\n",(0,r.jsx)(t.h4,{id:"val_rollout",children:"val_rollout"}),"\n",(0,r.jsx)(t.p,{children:"Use the validation set rollout scheduler to generate a batch of validation data. Validate every eval_steps steps."}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-python",children:"self.val_rollout_scheduler.get_batch(batch,self.pipeline_config.val_batch_size)\n"})}),"\n",(0,r.jsx)(t.h4,{id:"cal_ref_log_probs",children:"cal_ref_log_probs"}),"\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.code,{children:"reference.compute_log_probs"})," calculates the log probabilities of the reference model for the current batch data. Used for subsequent KL divergence penalty calculation to prevent the training policy from deviating too far from the initial policy."]}),"\n",(0,r.jsx)(t.h4,{id:"cal_old_log_probs_values",children:"cal_old_log_probs_values"}),"\n",(0,r.jsx)(t.p,{children:"Calculate the log probabilities (old policy probabilities) and value function estimates of the current training model for rollout data, which is a key step in the PPO algorithm for calculating the importance sampling ratio. actor_train.compute_log_probs uses the current training model to calculate the log probabilities of rollout data. critic.compute_values, if using GAE, also calculates the state value function."}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-python",children:'self.actor_train.compute_log_probs(batch, blocking=False)\nif self.pipeline_config.adv_estimator == "gae":\n  self.critic.compute_values(batch, blocking=False)\n'})}),"\n",(0,r.jsx)(t.h4,{id:"adv",children:"adv"}),"\n",(0,r.jsx)(t.p,{children:"Implements reward processing and advantage calculation, which is a core step in the PPO algorithm, responsible for converting environment rewards into training signals."}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.code,{children:"get_score_normalize_fn"})," standardizes the scores given by the reward model"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.code,{children:"apply_kl_penalty"})," adds the KL divergence between the log probabilities of actor_train and reference as a penalty term to the reward."]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.code,{children:"compute_advantage"})," calculates the advantage function based on the normalized rewards and the critic's value estimates."]}),"\n"]}),"\n",(0,r.jsx)(t.h4,{id:"critictrain_step-optional",children:"critic.train_step (optional)"}),"\n",(0,r.jsx)(t.p,{children:"Based on the collected data and calculated returns (or value differences), the critic updates its parameters to more accurately predict state values."}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-python",children:'if self.pipeline_config.adv_estimator == "gae":\n    self.critic.train_step(batch, blocking=False)\n'})}),"\n",(0,r.jsx)(t.h4,{id:"actor_traintrain_step",children:"actor_train.train_step"}),"\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.code,{children:"actor_train.train_step"})," updates its parameters based on the calculated advantage function and KL penalty, in order to generate text with higher rewards."]}),"\n",(0,r.jsx)(t.h4,{id:"compute_data_metrics",children:"compute_data_metrics"}),"\n",(0,r.jsx)(t.p,{children:"Calculate and statistics key metrics of training data, providing comprehensive data analysis for monitoring the training process."}),"\n",(0,r.jsx)(t.h4,{id:"do_checkpoint",children:"do_checkpoint"}),"\n",(0,r.jsx)(t.p,{children:"Save checkpoints"}),"\n",(0,r.jsx)(t.h4,{id:"trackerlog",children:"tracker.log"}),"\n",(0,r.jsx)(t.p,{children:"Generate text sample logs"})]})}function p(e={}){const{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},28453:(e,t,i)=>{i.d(t,{R:()=>l,x:()=>o});var n=i(96540);const r={},a=n.createContext(r);function l(e){const t=n.useContext(a);return n.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:l(e.components),n.createElement(a.Provider,{value:t},e.children)}}}]);