"use strict";(globalThis.webpackChunkdocs_roll=globalThis.webpackChunkdocs_roll||[]).push([[7741],{28453:(e,n,r)=>{r.d(n,{R:()=>t,x:()=>a});var i=r(96540);const s={},o=i.createContext(s);function t(e){const n=i.useContext(o);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:t(e.components),i.createElement(o.Provider,{value:n},e.children)}},97138:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>u,frontMatter:()=>t,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"User Guides/Advanced Features/async_parallel_rollout","title":"Agentic Asynchronous Parallel Rollout","description":"Introduction","source":"@site/docs/User Guides/Advanced Features/async_parallel_rollout.md","sourceDirName":"User Guides/Advanced Features","slug":"/User Guides/Advanced Features/async_parallel_rollout","permalink":"/ROLL/docs/User Guides/Advanced Features/async_parallel_rollout","draft":false,"unlisted":false,"editUrl":"https://github.com/alibaba/ROLL/tree/main/docs_roll/docs/User Guides/Advanced Features/async_parallel_rollout.md","tags":[],"version":"current","lastUpdatedAt":1764223793000,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Agentic Engineering Practice Documentation","permalink":"/ROLL/docs/User Guides/Agentic/agentic_engineer_practice"},"next":{"title":"ROLL Asynchronous Training User Guide","permalink":"/ROLL/docs/User Guides/Advanced Features/async_training"}}');var s=r(74848),o=r(28453);const t={},a="Agentic Asynchronous Parallel Rollout",l={},c=[{value:"Introduction",id:"introduction",level:2},{value:"Implementation Principle",id:"implementation-principle",level:2},{value:"Key Configuration Parameters",id:"key-configuration-parameters",level:2},{value:"Configuration Parameter Details",id:"configuration-parameter-details",level:3},{value:"max_env_num_per_worker",id:"max_env_num_per_worker",level:4},{value:"num_env_groups",id:"num_env_groups",level:4},{value:"group_size",id:"group_size",level:4},{value:"tags",id:"tags",level:4},{value:"num_groups_partition",id:"num_groups_partition",level:4},{value:"Usage Recommendations",id:"usage-recommendations",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"agentic-asynchronous-parallel-rollout",children:"Agentic Asynchronous Parallel Rollout"})}),"\n",(0,s.jsx)(n.h2,{id:"introduction",children:"Introduction"}),"\n",(0,s.jsxs)(n.p,{children:["Agentic asynchronous parallel rollout is an efficient multi-turn interaction processing mechanism in the ROLL framework. This mechanism manages multi-turn interaction processes at the environment (env) granularity, with each EnvManager independently executing ",(0,s.jsx)(n.code,{children:"run_rollout_loop"})," without synchronization barriers between environments, thus achieving efficient parallel processing."]}),"\n",(0,s.jsx)(n.h2,{id:"implementation-principle",children:"Implementation Principle"}),"\n",(0,s.jsx)(n.p,{children:"The core implementation scheme of agentic asynchronous parallel rollout is as follows:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Environment Granularity Management"}),": Multi-turn interaction processes are managed at the env granularity, implemented in ",(0,s.jsx)(n.code,{children:"roll/pipeline/agentic/env_manager/traj_env_manager.py"})]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Independent Execution"}),": Each EnvManager independently executes ",(0,s.jsx)(n.code,{children:"run_rollout_loop"})," without barriers between envs"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Batch Processing"}),": The ",(0,s.jsx)(n.code,{children:"rollout_scheduler.get_batch()"})," function in ",(0,s.jsx)(n.code,{children:"AgenticPipeline"})," blocks until the required ",(0,s.jsx)(n.code,{children:"batch_size"})," of trajectories is obtained"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["The key difference between synchronous and asynchronous training lies in whether the EnvManager.run_rollout_loop() process needs to be paused after ",(0,s.jsx)(n.code,{children:"rollout_scheduler.get_batch()"})," returns:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Synchronous Training"}),": After collecting ",(0,s.jsx)(n.code,{children:"batch_size"})," trajectories, the rollout_loop exits"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Asynchronous Training"}),": After collecting ",(0,s.jsx)(n.code,{children:"batch_size"})," trajectories, the pipeline continues with subsequent execution while continuing to execute EnvManager.run_rollout_loop"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"key-configuration-parameters",children:"Key Configuration Parameters"}),"\n",(0,s.jsx)(n.p,{children:"In Agentic, the most core configuration is EnvManagerConfig, which describes the distribution information of various environment quantities. The key configuration parameters for EnvManager are as follows:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-yaml",children:"train_env_manager:\n  max_env_num_per_worker: 16\n  num_env_groups: 128\n  # Under the same group, the env config and env seed are ensured to be equal\n  group_size: 8\n  tags: [FrozenLake]\n  num_groups_partition: [128] # If not set, all env names divide nums equally. Under the same group, the env config and env seed (prompt) are equal in each generation\n\nval_env_manager:\n  max_env_num_per_worker: 32\n  num_env_groups: 1024\n  group_size: 1 # Should be set to 1 because val temperature is set to 0 and same prompt leads to same output\n  tags: [SimpleSokoban, LargerSokoban, SokobanDifferentGridVocab, FrozenLake]\n  num_groups_partition: [256, 256, 256, 256] # If not set, all env names divide nums equally. Under the same group, the env config and env seed (prompt) are equal in each generation\n"})}),"\n",(0,s.jsx)(n.h3,{id:"configuration-parameter-details",children:"Configuration Parameter Details"}),"\n",(0,s.jsx)(n.h4,{id:"max_env_num_per_worker",children:"max_env_num_per_worker"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Meaning"}),": The maximum number of environments that can run simultaneously per worker (Ray Actor)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Purpose"}),": Controls the concurrency of environments per single worker, affecting memory usage and parallelism"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Example"}),": ",(0,s.jsx)(n.code,{children:"max_env_num_per_worker: 16"})," means each worker runs at most 16 environment instances simultaneously"]}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"num_env_groups",children:"num_env_groups"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Meaning"}),": The total number of environment groups during training"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Purpose"}),": Defines the total number of parallel environment groups, affecting training parallelism"]}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"group_size",children:"group_size"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Meaning"}),": The number of environment instances contained in each environment group"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Purpose"}),": Controls intra-group parallelism; environments within the same group have the same configuration and seed"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Notes"}),":","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"In training environments, typically set to a value greater than 1 to increase intra-group diversity"}),"\n",(0,s.jsx)(n.li,{children:"In validation environments, should be set to 1 because validation temperature is 0, and identical prompts produce identical outputs"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Example"}),":","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"group_size: 8"})," means each environment group contains 8 environment instances"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"num_env_groups: 128"})," means a total of 128 environment groups are created"]}),"\n",(0,s.jsxs)(n.li,{children:["Total number of env instances is: ",(0,s.jsx)(n.code,{children:"group_size * num_env_groups"})," = 1024"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"tags",children:"tags"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Meaning"}),": List of environment tags used to identify and select environment types"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Purpose"}),": Specifies the environment types to use; the framework loads corresponding environment implementations based on tags"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Example"}),": ",(0,s.jsx)(n.code,{children:"tags: [SimpleSokoban, FrozenLake]"})," indicates using SimpleSokoban and FrozenLake environment types"]}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"num_groups_partition",children:"num_groups_partition"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Meaning"}),": Group number allocation for different environment types"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Purpose"}),": Specifies the allocation ratio of different environment types in the total environment groups"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Default Behavior"}),": If not set, all environment names are equally divided into groups"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Example"}),":","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"num_groups_partition: [128]"})," means a single environment type occupies all 128 groups"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"num_groups_partition: [256, 256, 256, 256]"})," means four environment types each occupy 256 groups"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"usage-recommendations",children:"Usage Recommendations"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Reasonable Parallelism Settings"}),": Set ",(0,s.jsx)(n.code,{children:"max_env_num_per_worker"})," and ",(0,s.jsx)(n.code,{children:"num_env_groups"})," appropriately based on hardware resources (CPU, memory)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Environment Group Configuration"}),": Increase ",(0,s.jsx)(n.code,{children:"group_size"})," during training to improve intra-group parallelism; set to 1 during validation, which is required for GRPO-like algorithms that calculate advantages based on group trajectories"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Environment Type Allocation"}),": Reasonably allocate training resources for different environment types through ",(0,s.jsx)(n.code,{children:"tags"})," and ",(0,s.jsx)(n.code,{children:"num_groups_partition"})]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Resource Monitoring"}),": Monitor system resource usage to avoid resource exhaustion due to too many environment instances"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"By properly configuring these parameters, you can fully leverage the performance advantages of agentic asynchronous parallel rollout and improve training efficiency for multi-turn interaction tasks."})]})}function u(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}}}]);